## TIL Template

## 날짜: 2025-03-17

## 학습 내용

### ORM의 장단점과 SQL Mapper와의 차이점에 대해 설명해주세요.

객체와 RDB를 자동으로 매핑해주어 개발자가 SQL 쿼리문을 직접 작성하지 않고도 db에 접근할 수 있도록 도와줍니다. 이를 통해 생산성과 유지보수성이 향상되고, 도메인 로직에 집중할 수 있습니다. 그러나 복잡한 쿼리가 필요한 상황에서 ORM의 추상화가 오히려 부편함을 초래하거나, 성능 튜닝 시 ORM 내부 동작을 깊게 이해해야 하는 단점도 존재합니다. 반면, SQL Mapper는 쿼리를 직접 작성해야 하므로, 자유롭게 sql을 다룰 수 있지만, 관리의 복잡도가 높습니다. 즉, orm은 코드 레벨에서 db의 접근 로직을 단순화 해주는 반면, sql mapper는 복잡한 쿼리를 상세하게 제어해 더 세밀한 최적화가 가능합니다.

### Active Record 패턴과 Data Mapper 패턴의 차이를 설명해주세요. JPA는 둘 중 어떤 패턴을 따르는지 설명해주세요.

`active` 패턴은 모델 객체가 스스로 db의 crud 연산을 담당합니다. 이 방식은 구조가 단순하고 빠른 개발이 가능하지만, 도메인 로직과 db 접근이 뒤섞여 있어 복잡도가 증가할 수 있습니다. 반면, `data` 패턴은 db에 접근을 담당하는 별도의 mapper가 존재해, 엔티티는 순수한 비지니스 로직만 가지도록 분리합니다. 이 방식은 유지 보수성이 높지만, 구현이 다소 복잡할 수 있습니다. JPA는 `data mapper` 방식에 좀 더 가깝게 설계되었으며, 엔티티는 db와의 매핑만을 담당하고, 실제 db접근은 jpa 구현체 `hibernate` 등에 의해 처리되는 구조입니다.

### Hibernate와 JPA는 어떤 관계에 있는지 설명해주세요.

JPA는 자바 진영에서 정의된 ORM의 표준사항이며, 인터페이스와 어노테이션으로 이루어져 있습니다. `Hibernate` 는 이러한 JPA 표준을 구현한 구현체 중 하나로서, 실제로 애플리케이션에서 JPA를 사용하면, 내부적으로 `Hibernate` 가 동작하여 쿼리를 생성하고 db에 전달하게 됩니다. 즉, JPA는 “이렇게 동작해야햐 한다”라는 규약과 API를 정의하고, Hibernate는 그 규약을 충실히 구현하며 다양한 추가기능도 제공하는 라이브러리 입니다.

### JPA Entity와 DB 테이블 매핑 과정에서 주의해야 할 점에 대해서 설명해주세요.

JPA로 엔티티를 생서할때는 반드시 파라미터가 없는 기본 생성자가 존재해야 하고, 식별을 위한 `@ID`가 존재해야 합니다. 그리고 테이블의 칼럼은 `@Column` 으로 명확히 제약조건을 구분하고, 양방향 매핑시 `@mappedBy` 설정을 명확히 하고, 외래키 관리의 주체를 명확히해 중복쿼리나 순환참조의 오류가 발생하지 않도록 합니다.

### Lazy Loading을 사용할 때 주의해야할 점에 대해서 설명해주세요.

실제로 필요한 시점까지 데이터를 불러오지 않기때문에, 초기 비용을 줄여주는 장점이 있습니다. 하지만, 트랜잭션이 종료돈 상태에서 지연 로딩이 발생하면, 영속성 컨텍스트가 이미 닫혀 있어서 `LazyInitializationException` 오류가 발생할 수 있습니다. 또한, 잘못된 사용으로 인해 연관 엔티티마다 추가 쿼리가 발생해 N+1 문제가 생기거나, 예상치 않은 시점에 데이터가 로딩되어 성능 저하로 이어질 수 있습니다. 따라서 서비스 계층의 트랜잭션 범위 안에서 필요한 데이터를 미리 로딩하거나, `Fetch Join` 등의 방식을 적절히 사용하는 등의 로딩 전략을 사전에 설계해야 합니다.

### JPA에서 N+1 문제를 해결하기 위한 방법을 알려주세요

가장 대표적인 방법으로 `Join Fetch` , `Fetch Join` 을 사용해 연관된 엔티티를 한번에 불러오는 방법이 있습니다. 이 방식을 사용한면 지연로딩이 존재하지 않아 N+1 문제를 예방할 수 있습니다. 또한, `@EntityGraph` 어노테이션을 사용해 특정 속성들을 미리 로딩하도록 지정하거나, Batch Size 설정을 통해 한 번에 여러 연관 데이터를 로딩하는 방식으로 성능을 개선할 수도 있습니다.

### JPA에서 save()메소드는 어떻게 동작하는지 설명해주세요.

Spring Data JPA에서는 JPA `EntityManager` 를 통해 `persist()` 또는 `merge()` 작업을 수행한다. 새로 영속화 되지 않은 엔티티라면 `persist()` 가 호출되어 새로운 레코드가 INSERT 되고, 이미 영속 상태이거나 식별자가 존재하는 엔티티라면 `merge()` 가 호출되어 변경내용을 UPDATE 쿼리로 반영합니다. 내부적으로 영속성 컨텍스트가 엔티티 상태를 추적하고, 트랜잭션이 커밋될 때 실제 SQL 쿼리가 실행되어 DB에 반영됩니다. 따라서, `save()` 호출 시점에 바로 db에 반영되는 것이 아니라, 영속성 컨텍스트 내에서 일단 대기 상태로 두고, 트랜잭션을 커밋할때 실제로 반영된다는 점을 인지해야 합니다.
